<html>

<head>
    <script src="js/jquery-3.3.1.min.js"></script>
    <script src="js/three.js"></script>
    <script src="js/OBJLoader.js"></script>
    <link href='https://fonts.googleapis.com/css?family=Amatic SC' rel='stylesheet'>

    <style>
    body {
        margin: 0;
        font-family: 'Amatic SC';
        font-size: 25pt;
        /* color: white; */
    }

    body *{
        font-family: 'Amatic SC';
        font-size: 25pt;
        color: white;
    }

    canvas {
        width: 100%;
        height: 100%;
    }

    #playzone{
        position: absolute;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: linear-gradient(to bottom, rgba(146,205,221,1) 0%, rgba(117,189,209,1) 27%, rgba(245,124,103,1) 64%, rgba(240, 120, 40, 0.89) 83%, rgba(240,120,40,1) 100%);
    }

    .container{
        width: 100%;
        height: 100%;
        position: absolute;
        z-index: 100;
        text-align: center;
    }

    #welcomeContainer{
        top: 30%;
    }

    #greeting{
        font-size: 40pt;
    }

    input{
        border: none;
        border-bottom: 1px solid #fff;
        background: transparent;
        font-family: 'Amatic SC';
        font-size: 30pt;
        text-align: center;
    }

    input:focus{
        outline: none;
    }

    #goBtn{
        width: 200px;
        border: 1px solid #fff;
        background: transparent;
        display: block;
        margin: 0 auto;
        margin-top: 20px;
        outline: none;
    }

    #goBtn:hover{
        background: rgba(0, 0, 0, 0.5);
        cursor: pointer;
    }

    #gameContainer{
        top: 20%;
        display: none;
        cursor: pointer;
        select: none;
        -webkit-user-select: none; /* webkit (safari, chrome) browsers */
        -moz-user-select: none; /* mozilla browsers */
        -khtml-user-select: none; /* webkit (konqueror) browsers */
        -ms-user-select: none; /* IE10+ */
    }

    progress{
        height: 5px;
        width: 50%;
        -webkit-appearance: none;
        border: none;
    }

    progress::-webkit-progress-bar {
        background: transparent;
        border-radius: 10px;
        padding: 2px;
    }

    progress::-webkit-progress-value {
        border-radius: 10px;
        box-shadow: inset 0 1px 1px 0 rgba(255, 255, 255, 0.4);
        background: white;
    }

    #score{
        position: absolute;
        z-index: 100;
        margin: 0 auto;
        top: 5%;
        left: 5%;
    }


    </style>

    <script>

    var name;
    var ctr = 0;
    var gameEnd = false;
    var timeleft = 10;
    var score = 0;

    $(document).ready(function(){
        $('#goBtn').click(function(){
            if($('#nameIn').val() !== ""){
                $('#welcomeContainer').hide();

                name = $('#nameIn').val();

                $('#inst').text($('#inst').text() + name + "!");

                $('#gameContainer').show();

                startTimer();
            }
        });

        $('#gameContainer').click(function(){
            if(!gameEnd){
                ctr++;
                $('#clickCtr').text(ctr + " clicks");
            }
        });

    });

    function startTimer(){
        var clickTimer = setInterval(function(){
            document.getElementById("progressBar").value = 10 - --timeleft;
            if(timeleft < 0){
                clearInterval(clickTimer);
                gameEnd = true;
                $("#gameContainer").hide();
                score = Math.floor(ctr / 10);
                $("#score").text("Score: " + score);
            }
        },1000);
    }

    </script>
</head>

<body>
    <div id="playzone">

        <div id="welcomeContainer" class="container">
            <div id="greeting">
                Hello,
            </div>
            <input id="nameIn"/>
            <button id="goBtn">Go</button>
        </div>

        <div id="gameContainer" class="container">
            <div id="inst">
                Click as fast as you can,
            </div>

            <div id="clickCtr">
                0 clicks
            </div>

            </br>

            <progress value="0" max="10" id="progressBar"></progress>
        </div>

        <div id="score">

        </div>

    </div>

    <script>

    /* SCENE VARIABLES */
    var scene,
    camera, FOV, aspectRatio, near, far, LOCAL_HEIGHT, LOCAL_WIDTH,
    renderer, container;

    /* SCENE OBJECTS */
    var cloudArray = [];

    /* LIGHTING */
    var ambientLight, hemisphereLight, shadowLight;

    var sea;
    var sky;

    /* COLOR PALETTES */
    var colors = {
        red:0xf25346,
        white:0xd8d0d1,
        brown:0x59332e,
        pink:0xF5986E,
        brownDark:0x23190f,
        blue:0x68c3c0,
    };

    window.addEventListener('load', init, false);

    function init() {
        // set up the scene, the camera and the renderer
        createScene();

        // add the lights
        createLights();

        // add the objects
        // createPlane();
        createSea();
        createSky();

        var axesHelper = new THREE.AxesHelper( 1000 );
        scene.add( axesHelper );

        // var xAxis = new THREE.Geometry ();
        // 	xAxis.vertices.push (new THREE.Vector3 (-1000, 0, -1000));
        // 	xAxis.vertices.push (new THREE.Vector3 (1000, 0, -1000));
        // var yAxis = new THREE.Geometry ();
        // 	yAxis.vertices.push (new THREE.Vector3 (0, -1000, -1000));
        // 	yAxis.vertices.push (new THREE.Vector3 (0, 1000, -1000));
        // var red = new THREE.MeshBasicMaterial ({color: 0xff0000});
        // var green = new THREE.MeshBasicMaterial ({color: 0x00ff00});
        //             scene.add (new THREE.Line (xAxis, red));
        // scene.add (new THREE.Line (yAxis, green));

        // start a loop that will update the objects' positions
        // and render the scene on each frame
        loop();
    }

    function createScene() {
        LOCAL_HEIGHT = window.innerHeight;
        LOCAL_WIDTH = window.innerWidth;

        scene = new THREE.Scene();

        scene.fog = new THREE.Fog(0xf7ddc0, 100, 950);

        // Create the camera
        aspectRatio = LOCAL_WIDTH / LOCAL_HEIGHT;
        FOV = 60;
        near = 1;
        far = 10000;
        camera = new THREE.PerspectiveCamera(FOV, aspectRatio, near, far);

        camera.position.set(0, 100, 200);

        renderer = new THREE.WebGLRenderer({
            alpha: true,
            antialias: true
        });

        renderer.setSize(LOCAL_WIDTH, LOCAL_HEIGHT);
        renderer.shadowMap.enabled = true;

        container = document.getElementById('playzone');
        container.appendChild(renderer.domElement);

        window.addEventListener('resize', handleWindowResize, false);
    }

    function handleWindowResize() {
        // update height and width of the renderer and the camera
        LOCAL_HEIGHT = window.innerHeight;
        LOCAL_WIDTH = window.innerWidth;
        renderer.setSize(LOCAL_WIDTH, LOCAL_HEIGHT);
        camera.aspect = LOCAL_WIDTH / LOCAL_HEIGHT;
        camera.updateProjectionMatrix();
    }

    function createLights() {
        ambientLight = new THREE.AmbientLight(0xdc8874, .5);

        // gradient: sky to ground
        hemisphereLight = new THREE.HemisphereLight(0xaaaaaa,0x000000, .9);

        shadowLight = new THREE.DirectionalLight(0xffffff, .9);
        shadowLight.position.set(150, 350, 350);
        shadowLight.castShadow = true;

        // define the visible area of the projected shadow
        shadowLight.shadow.camera.left = -400;
        shadowLight.shadow.camera.right = 400;
        shadowLight.shadow.camera.top = 400;
        shadowLight.shadow.camera.bottom = -400;
        shadowLight.shadow.camera.near = 1;
        shadowLight.shadow.camera.far = 1000;

        shadowLight.shadow.mapSize.width = 2048;
        shadowLight.shadow.mapSize.height = 2048;

        scene.add(ambientLight);
        scene.add(hemisphereLight);
        scene.add(shadowLight);
    }

    function Sea(){
        // create the geometry (shape) of the cylinder;
        // the parameters are:
        // radius top, radius bottom, height, number of segments on the radius, number of segments vertically
        // var geom = new THREE.CylinderGeometry(700,600,500,40,10);
        var geom = new THREE.CylinderGeometry(600,600,800,40,10);

        // rotate the geometry on the z axis
        geom.applyMatrix(new THREE.Matrix4().makeRotationZ(-Math.PI/2));

        // important: by merging vertices we ensure the continuity of the waves
        geom.mergeVertices();

        // get the vertices
        var l = geom.vertices.length;

        // stores data associated w/ each vertex
        this.waves = [];

        for (var i=0; i<l; i++){
            // get each vertex
            var v = geom.vertices[i];

            // store some data associated to it
            this.waves.push({y:v.y,
                x:v.x,
                z:v.z,
                // a random angle
                ang:Math.random()*Math.PI*2,
                // a random distance
                amp:5 + Math.random()*30,
                // a random speed between 0.016 and 0.048 radians / frame
                speed:0.016 + Math.random()*0.032
            });
        };

        // create the material
        var mat = new THREE.MeshPhongMaterial({
            color:colors.blue,
            transparent:true,
            opacity:0.9,
            flatShading:true
        });

        // To create an object in Three.js, we have to create a mesh
        // which is a combination of a geometry and some material
        this.mesh = new THREE.Mesh(geom, mat);

        // Allow the sea to receive shadows
        this.mesh.receiveShadow = true;
    }

    Sea.prototype.moveWaves = function (){

        // get the vertices
        var verts = this.mesh.geometry.vertices;
        var l = verts.length;

        for (var i=0; i<l; i++){
            var v = verts[i];

            // get the data associated to it
            var vprops = this.waves[i];

            // update the position of the vertex
            v.x = vprops.x + Math.cos(vprops.ang)*vprops.amp;
            v.y = vprops.y + Math.sin(vprops.ang)*vprops.amp;

            // increment the angle for the next frame
            //vprops.ang += vprops.speed;

        }

        // Tell the renderer that the geometry of the sea has changed.
        // In fact, in order to maintain the best level of performance,
        // three.js caches the geometries and ignores any changes
        // unless we add this line
        this.mesh.geometry.verticesNeedUpdate=true;

        // sea.mesh.rotation.x += .0025;
    }

    function createSea(){
        sea = new Sea();

        // push it a little bit at the bottom of the scene
        sea.mesh.position.y = -600;

        // add the mesh of the sea to the scene
        scene.add(sea.mesh);
    }

    function Cloud(){
        // Create an empty container that will hold the different parts of the cloud
        this.mesh = new THREE.Object3D();

        // create a cube geometry;
        // this shape will be duplicated to create the cloud
        var geom = new THREE.BoxGeometry(20,20,20);
        // var geom = new THREE.IcosahedronGeometry(20,0);

        // create a material; a simple white material will do the trick
        var mat = new THREE.MeshPhongMaterial({
            color:colors.white,
            opacity:.8
        });

        // duplicate the geometry a random number of times
        var nBlocs = 4 + Math.floor(Math.random() * 3);
        for (var i=0; i<nBlocs; i++ ){

            // create the mesh by cloning the geometry
            var m = new THREE.Mesh(geom, mat);

            // set the position and the rotation of each cube randomly
            m.position.x = i*15;
            m.position.y = Math.random()*15;
            m.position.z = Math.random()*10;
            m.rotation.z = Math.random()*Math.PI*2;
            m.rotation.y = Math.random()*Math.PI*2;

            // set the size of the cube randomly
            var s = .6 + Math.random()*.9;
            m.scale.set(s,s,s);

            // allow each cube to cast and to receive shadows
            m.castShadow = true;
            m.receiveShadow = true;

            // add the cube to the container we first created
            this.mesh.add(m);
        }
    }

    function Sky(){
        // Create an empty container
        this.mesh = new THREE.Object3D();

        // choose a number of clouds to be scattered in the sky
        this.nClouds = 40;

        // To distribute the clouds consistently,
        // we need to place them according to a uniform angle
        var stepAngle = Math.PI*2 / this.nClouds;

        // 45 degrees in radians
        var theta = 45 / 180 * Math.PI;

        // const. distance between sea and clouds
        var clearance = 200;

        // create the clouds
        for(var i=0; i<this.nClouds; i++){
            var c = new Cloud();

            // set the rotation and the position of each cloud;
            // for that we use a bit of trigonometry
            var a = stepAngle*i; // this is the final angle of the cloud
            var h = 750 + Math.random()*200; // this is the distance between the center of the axis and the cloud itself

            var thetaP = theta * (i % 8);
            var dist =  600 + Math.random() * 250 + clearance;

            var posY = Math.sin(thetaP) * dist;
            var posX = Math.cos(thetaP) * dist;

            console.log(posX, posY);

            posX -= Math.random() * 225 + Math.random() * 450;

            if(posX >= 0 && posY >= 0){  // Quadrant I
                posY += clearance;
            }
            else if(posX < 0 && posY > 0){  // Quadrant II
                posY += clearance;
            }
            else if(posX < 0 && posY < 0){  // Quadrant III
                while(posY > -1200)
                posY = posY - Math.random() * 150;

                posY -= clearance;
            }
            else if(posX > 0 && posY < 0){  // Quadrant IV
                while(posY > -1200)
                posY = posY - Math.random() * 150;

                posY -= clearance;
            }

            c.mesh.position.y = posY;
            c.mesh.position.x = posX;

            var posZ = Math.random() * 100 * Math.random() * 25;

            var choose = Math.random() * 10;

            if(choose < 5)
            c.mesh.position.z = -1 * posZ;
            else
            c.mesh.position.z = posZ;

            // console.log(c.mesh.position);

            // we also set a random scale for each cloud
            var s = 1+Math.random()*2;
            c.mesh.scale.set(s,s,s);

            cloudArray.push(c);

            // do not forget to add the mesh of each cloud in the scene
            this.mesh.add(c.mesh);
        }
    }

    // Now we instantiate the sky and push its center a bit
    // towards the bottom of the screen

    function createSky(){
        sky = new Sky();
        sky.mesh.position.y = -600;
        scene.add(sky.mesh);
    }

    function loop(){
        // Rotate the propeller, the sea and the sky
        // airplane.propeller.rotation.x += 0.3;
        sea.mesh.rotation.x += .0075;
        sky.mesh.rotation.x += .005;

        // respawnClouds();

        sea.moveWaves();

        // render the scene
        renderer.render(scene, camera);

        // call the loop function again
        requestAnimationFrame(loop);
    }

    </script>
</body>

</html>
